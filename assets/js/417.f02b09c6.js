(window.webpackJsonp=window.webpackJsonp||[]).push([[417],{899:function(a,t,v){"use strict";v.r(t);var _=v(14),e=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"java进阶-io框架"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java进阶-io框架"}},[a._v("#")]),a._v(" Java进阶-IO框架")]),a._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[a._v("Hi")]),a._v(" "),v("p",[a._v("几乎所有的程序都离不开信息的输入和输出，比如从键盘读取数据，从文件中获取或者向文件中存入数据，在显示器上显示数据。这些情况下都会涉及有关输入/输出的处理。")]),a._v(" "),v("p",[a._v("在简单的说：IO就是和Java以外的文件打交道。")]),a._v(" "),v("p",[a._v("既然要处理文件，那么就需要Java提供的IO接口进行处理：")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("Input指从外部读入数据到内存")])]),a._v(" "),v("li",[v("p",[a._v("Output指把数据从内存输出到外部")])])]),a._v(" "),v("p",[a._v("要掌握Java的IO，核心就是：选择合适的IO流读写文件。")])]),a._v(" "),v("h2",{attrs:{id:"什么是io"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是io"}},[a._v("#")]),a._v(" 什么是IO")]),a._v(" "),v("p",[a._v("I/O 是指Input/Output，即输入和输出。")]),a._v(" "),v("ul",[v("li",[a._v("Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。")]),a._v(" "),v("li",[a._v("Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。")])]),a._v(" "),v("p",[a._v("Java程序在执行的时候，是在内存进行的，外部的数据需要读写到内存才能处理；而在内存中的数据是随着程序结束就消失的，有时候我们也需要把数据输出到外部文件。")]),a._v(" "),v("p",[a._v("Java中，是通过流 处理IO的，这种处理模式称为 IO流，IO流是一种顺序读写数据的模式。")]),a._v(" "),v("p",[a._v("你可以想象它是一根水管，数据就像水一样， 起点—终点 可互相流动。")]),a._v(" "),v("img",{attrs:{src:a.$withBase("/guide/java-io1.jpg"),alt:"mixureSecure"}}),a._v(" "),v("h3",{attrs:{id:"_1-1、流的特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1、流的特点"}},[a._v("#")]),a._v(" 1.1、流的特点：")]),a._v(" "),v("ul",[v("li",[a._v("先进先出：最先写入输出流的数据最先被输入流读取到。")]),a._v(" "),v("li",[a._v("顺序存取：可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。（RandomAccessFile除外）")]),a._v(" "),v("li",[a._v("只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。")])]),a._v(" "),v("h3",{attrs:{id:"_1-2、io流的分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2、io流的分类"}},[a._v("#")]),a._v(" 1.2、IO流的分类")]),a._v(" "),v("h4",{attrs:{id:"_1-2-1、按方向分"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1、按方向分"}},[a._v("#")]),a._v(" 1.2.1、按方向分")]),a._v(" "),v("p",[a._v("按数据流的方向分为 输入流、输出流，是相对内存来说的。")]),a._v(" "),v("ul",[v("li",[a._v("输入流：从外部（数据源）把数据输入到程序（内存）。")]),a._v(" "),v("li",[a._v("输出流：把程序的数据（内存）输出到外部（数据源）。")])]),a._v(" "),v("img",{attrs:{src:a.$withBase("/guide/java-io2.jpg"),alt:"mixureSecure"}}),a._v(" "),v("h4",{attrs:{id:"_1-2-2、按处理数据类型分"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-2、按处理数据类型分"}},[a._v("#")]),a._v(" 1.2.2、按处理数据类型分")]),a._v(" "),v("p",[a._v("按处理的数据类型可分为 字节流、字符流")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("1字符 = 2字节 、 1字节(byte) = 8位(bit)\n")])])]),v("ul",[v("li",[a._v("字节流：每次读 （写）一个字节，当传输的资源文件有中文时，就会出现乱码，读写的单位是byte，在InputStream/OutputStream中单向流动")]),a._v(" "),v("li",[a._v("字符流：每次读取(写出)两个字节，有中文时，使用该流就可以正确传输显示中文，读写的单位是char，在Reader/Writer中单向流动")])]),a._v(" "),v("p",[v("strong",[a._v("字节流和字符流的原理是相同的，只不过处理的单位不同而已。后缀是Stream是字节流，而后缀是Reader，Writer是字符流。")])]),a._v(" "),v("p",[v("strong",[a._v("为什么要有字符流？")])]),a._v(" "),v("p",[a._v("Java中字符是采用Unicode标准，Unicode 编码中，一个英文为一个字节，一个中文为两个字节。但是编码不同，中文字符占的字节数不一样，而在UTF-8编码中，一个中文字符是3个字节。")]),a._v(" "),v("p",[a._v("如果统一使用字节流处理中文，因为读写是一个字节一个字节，这样就会对中文字符有影响，就会出现乱码。")]),a._v(" "),v("p",[a._v("为了更方便地处理中文这些字符，Java就推出了字符流。")]),a._v(" "),v("p",[a._v("字节流和字符流的其他区别：")]),a._v(" "),v("ul",[v("li",[a._v("1、字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，但不能处理图像视频等非文本文件。")]),a._v(" "),v("li",[a._v("2、字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。")])]),a._v(" "),v("h4",{attrs:{id:"_1-2-3、按功能分"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3、按功能分"}},[a._v("#")]),a._v(" 1.2.3、按功能分")]),a._v(" "),v("p",[a._v("按功能不同分为 "),v("strong",[a._v("节点流、处理流")])]),a._v(" "),v("ul",[v("li",[a._v("节点流：以从或向一个特定的地方（节点）读写数据。如FileInputStream")]),a._v(" "),v("li",[a._v("处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装.")])]),a._v(" "),v("h4",{attrs:{id:"_1-2-4、按有无缓冲分"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-4、按有无缓冲分"}},[a._v("#")]),a._v(" 1.2.4、按有无缓冲分")]),a._v(" "),v("p",[a._v("还有一种流是缓冲流，区别于没有缓冲的流。")]),a._v(" "),v("p",[a._v("因为程序和内存交互很快，而程序和磁盘交互是很慢的，这样会导致程序出现性能问题。")]),a._v(" "),v("p",[a._v("为了减少程序与磁盘的交互，是提升程序效率，引入了缓冲流。")]),a._v(" "),v("p",[a._v("普通流每次读写一个字节，而缓冲流在内存中设置一个缓存区，缓冲区先存储足够的待操作数据后，再与内存或磁盘进行交互。这样，在总数据量不变的情况下，通过提高每次交互的数据量，减少了交互次数。")]),a._v(" "),v("p",[a._v("有缓冲的流，类名前缀是带有Buffer的，比如BufferedInputStream、BufferedReader")]),a._v(" "),v("img",{attrs:{src:a.$withBase("/guide/java-io4.jpg"),alt:"mixureSecure"}})])}),[],!1,null,null,null);t.default=e.exports}}]);