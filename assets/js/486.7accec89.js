(window.webpackJsonp=window.webpackJsonp||[]).push([[486],{948:function(e,t,r){"use strict";r.r(t);var a=r(14),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[e._v("#")]),e._v(" 数据结构")]),e._v(" "),r("h2",{attrs:{id:"队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[e._v("#")]),e._v(" 队列")]),e._v(" "),r("ul",[r("li",[r("p",[r("a",{attrs:{href:"https://www.cnblogs.com/lemon-flm/p/7877898.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("《java队列——queue详细分析》"),r("OutboundLink")],1)]),e._v(" "),r("ul",[r("li",[e._v("非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。")]),e._v(" "),r("li",[e._v("阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。")])])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://www.cnblogs.com/mantu/p/5802393.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》"),r("OutboundLink")],1)])])]),e._v(" "),r("h2",{attrs:{id:"集合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#集合"}},[e._v("#")]),e._v(" 集合")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://blog.csdn.net/qq_33642117/article/details/52040345",target:"_blank",rel:"noopener noreferrer"}},[e._v("《Java Set集合的详解》"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"链表、数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链表、数组"}},[e._v("#")]),e._v(" 链表、数组")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://blog.csdn.net/wz249863091/article/details/52853360",target:"_blank",rel:"noopener noreferrer"}},[e._v("《Java集合详解--什么是List》"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"字典、关联数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#字典、关联数组"}},[e._v("#")]),e._v(" 字典、关联数组")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://baike.xsoftlab.net/view/250.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("《Java map 详解 - 用法、遍历、排序、常用API等》"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[e._v("#")]),e._v(" 栈")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://blog.csdn.net/javazejian/article/details/53362993",target:"_blank",rel:"noopener noreferrer"}},[e._v("《java数据结构与算法之栈（Stack）设计与实现》"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"http://www.runoob.com/java/java-stack-class.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("《Java Stack 类》"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/f2006116/article/details/51375225",target:"_blank",rel:"noopener noreferrer"}},[e._v("《java stack的详细实现分析》"),r("OutboundLink")],1),e._v(" "),r("ul",[r("li",[e._v("Stack 是线程安全的。")]),e._v(" "),r("li",[e._v("内部使用数组保存数据，不够时翻倍。")])])])]),e._v(" "),r("h2",{attrs:{id:"树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#树"}},[e._v("#")]),e._v(" 树")]),e._v(" "),r("h3",{attrs:{id:"二叉树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[e._v("#")]),e._v(" 二叉树")]),e._v(" "),r("p",[e._v("每个节点最多有两个叶子节点。")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://blog.csdn.net/cai2016/article/details/52589952",target:"_blank",rel:"noopener noreferrer"}},[e._v("《二叉树》"),r("OutboundLink")],1)])]),e._v(" "),r("h3",{attrs:{id:"完全二叉树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#完全二叉树"}},[e._v("#")]),e._v(" 完全二叉树")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[e._v("《完全二叉树》"),r("OutboundLink")],1),e._v(" "),r("ul",[r("li",[e._v("叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。")])])])]),e._v(" "),r("h3",{attrs:{id:"平衡二叉树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#平衡二叉树"}},[e._v("#")]),e._v(" 平衡二叉树")]),e._v(" "),r("p",[e._v("左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"http://www.cnblogs.com/polly333/p/4798944.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("《浅谈数据结构-平衡二叉树》"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("《浅谈算法和数据结构: 八 平衡查找树之2-3树》"),r("OutboundLink")],1)])]),e._v(" "),r("h3",{attrs:{id:"二叉查找树-bst"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二叉查找树-bst"}},[e._v("#")]),e._v(" 二叉查找树（BST）")]),e._v(" "),r("p",[e._v("二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("《浅谈算法和数据结构: 七 二叉查找树》"),r("OutboundLink")],1)])]),e._v(" "),r("h3",{attrs:{id:"红黑树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#红黑树"}},[e._v("#")]),e._v(" 红黑树")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://blog.csdn.net/sun_tttt/article/details/65445754",target:"_blank",rel:"noopener noreferrer"}},[e._v("《最容易懂得红黑树》"),r("OutboundLink")],1),e._v(" "),r("ul",[r("li",[e._v("添加阶段后，左旋或者右旋从而再次达到平衡。")])])]),e._v(" "),r("li",[r("a",{attrs:{href:"http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("《浅谈算法和数据结构: 九 平衡查找树之红黑树》"),r("OutboundLink")],1)])]),e._v(" "),r("h3",{attrs:{id:"b-b-b-树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#b-b-b-树"}},[e._v("#")]),e._v(" B，B+，B*树")]),e._v(" "),r("p",[e._v("MySQL是基于B+树聚集索引组织表")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://blog.csdn.net/aqzwss/article/details/53074186",target:"_blank",rel:"noopener noreferrer"}},[e._v("《B-树，B+树，B*树详解》"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/bigtree_3721/article/details/73632405",target:"_blank",rel:"noopener noreferrer"}},[e._v("《B-树，B+树与B*树的优缺点比较》"),r("OutboundLink")],1),e._v(" "),r("ul",[r("li",[e._v("B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。")])])])]),e._v(" "),r("h3",{attrs:{id:"lsm-树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lsm-树"}},[e._v("#")]),e._v(" LSM 树")]),e._v(" "),r("p",[e._v("LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。\nHbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。")]),e._v(" "),r("ul",[r("li",[r("p",[r("a",{attrs:{href:"https://blog.csdn.net/dbanote/article/details/8897599",target:"_blank",rel:"noopener noreferrer"}},[e._v("《LSM树 VS B+树》"),r("OutboundLink")],1)]),e._v(" "),r("ul",[r("li",[e._v("B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。")]),e._v(" "),r("li",[e._v("LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。")])])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://blog.csdn.net/u014774781/article/details/52105708",target:"_blank",rel:"noopener noreferrer"}},[e._v("《LSM树（Log-Structured Merge Tree）存储引擎》"),r("OutboundLink")],1)]),e._v(" "),r("ul",[r("li",[e._v("极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。")]),e._v(" "),r("li",[e._v("优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。")]),e._v(" "),r("li",[e._v("Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。")])])])]),e._v(" "),r("h2",{attrs:{id:"bitset"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bitset"}},[e._v("#")]),e._v(" BitSet")]),e._v(" "),r("p",[e._v("经常用于大规模数据的排重检查。")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"http://www.runoob.com/java/java-bitset-class.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("《Java Bitset类》"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/caiandyong/article/details/51581160",target:"_blank",rel:"noopener noreferrer"}},[e._v("《Java BitSet（位集）》"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports}}]);